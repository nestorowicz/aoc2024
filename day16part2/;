use std::{collections::{HashMap, HashSet}, io::{read_to_string, stdin}};
use aoc::{Point, Map, Direction, Ray};

const START: char = 'S';
const END: char = 'E';
const WALL: char = '#';
const INITIAL_DIRECTION: Direction = Direction::Right;
const COST_MOVE: u64 = 1;
const COST_ROTATE: u64 = 1000;

struct Input {
    map: Map<char>,
    start: Point,
    end: Point
}

type Memory = HashMap<Point, u64>;

fn main() {
    let input = parse_input();
    aoc::print_char_map(&input.map);
    let mut memory: HashMap<Point, u64> = HashMap::new();
    calculate_min_cost(&input, &Some(Ray::new(input.start, INITIAL_DIRECTION)), &mut memory, 0);
    let min_cost = *memory.get(&input.end).unwrap_or(&0);
    let paths = find_path_with_cost(&input, &Some(Ray::new(input.start, INITIAL_DIRECTION)), &vec![], 0, min_cost);
    let paths_set: HashSet<Point> = paths.into_iter().collect();
    println!("min cost {}", min_cost);
    println!("tiles in cheapest paths {}", paths_set.len());

    let mut map = input.map.clone();
    for k in  paths_set.iter() {
        map.state.get_mut(k.y).unwrap()[k.x] = 'O';
    }
    aoc::print_char_map(&map);
}

fn parse_input() -> Input {
    let map = Map{state:
        read_to_string(stdin()).unwrap()
            .lines()
            .map(|s| s.chars().collect())
            .collect()
    };
    let start = map.find_position(&START).unwrap();
    let end = map.find_position(&END).unwrap();
    return Input{map, start, end};
}

fn calculate_min_cost(input: &Input, ray: &Option<Ray>, memory: &mut Memory, cost: u64) {
    let Some(ray) = ray else { return };
    let Some(symbol) = input.map.peek(&ray.point) else { return };
    if *symbol == WALL { return }
    if memory.contains_key(&ray.point) && *memory.get(&ray.point).unwrap() < cost { return }
    memory.insert(ray.point, cost);
    if *symbol == END { return };
    calculate_min_cost(input, &ray.move_by_one(), memory, cost + COST_MOVE);
    calculate_min_cost(input, &ray.rotate_90_clockwise().move_by_one(), memory, cost + COST_ROTATE + COST_MOVE);
    calculate_min_cost(input, &ray.rotate_90_counter_clockwise().move_by_one(), memory, cost + COST_ROTATE + COST_MOVE);
}

fn find_path_with_cost(input: &Input, ray: &Option<Ray>, visited: &Vec<Point>, cost: u64, expected_cost: u64) -> Vec<Point> {
    let Some(ray) = ray else { return vec![] };
    let Some(symbol) = input.map.peek(&ray.point) else { return vec![] };
    if *symbol == WALL { return vec![] }
    if visited.contains(&ray.point) { return vec![] }
    let mut visited = visited.clone();
    visited.push(ray.point);

    if *symbol == END {
        if cost == expected_cost {
            return visited
        }
        return vec![];
    };
    if cost > expected_cost { return vec![] }
    return vec![
        find_path_with_cost(input, &ray.move_by_one(), &visited, cost + COST_MOVE, expected_cost),
        find_path_with_cost(input, &ray.rotate_90_clockwise().move_by_one(), &visited, cost + COST_MOVE + COST_ROTATE, expected_cost),
        find_path_with_cost(input, &ray.rotate_90_counter_clockwise().move_by_one(), &visited, cost + COST_MOVE + COST_ROTATE, expected_cost)
    ].into_iter().flatten().collect();
}

